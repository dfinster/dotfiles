#!/bin/zsh
#
# dotfiles - Manage dotfiles repository

# Function-scoped state variables with clear prefixes
_DF_TARGET_BRANCH=""
_DF_CURRENT_BRANCH=""

# Configuration file path
readonly _DF_CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/dotfiles.conf"

# Cache file path
readonly _DF_CACHE_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/dotfiles/.last-check"

# Default configuration values
_DF_DEFAULT_BRANCH="main"
_DF_CACHE_DURATION=43200  # 12 hours in seconds
_DF_NETWORK_TIMEOUT=30
_DF_AUTO_UPDATE_PLUGINS=true
_DF_GITHUB_URL="https://github.com/dfinster/dotfiles"

# Color constants
readonly _DF_RED='\033[91m'
readonly _DF_YELLOW='\033[93m'
readonly _DF_GREEN='\033[92m'
readonly _DF_BLUE='\033[94m'
readonly _DF_RESET='\033[0m'

# Create configuration file template if it doesn't exist
_df_create_config_template() {

    if [[ ! -f "$_DF_CONFIG_FILE" ]]; then
        cat > "$_DF_CONFIG_FILE" <<'EOF'
# Dotfiles Configuration
# This file is not tracked in git and contains user-specific settings

# Default branch to use
default_branch=main

# Cache duration in seconds (12 hours = 43200)
cache_duration=43200

# Network timeout for git operations in seconds
network_timeout=30

# Auto-update antidote plugins during dotfiles update
auto_update_plugins=true

# GitHub repository URL
github_url=https://github.com/dfinster/dotfiles
EOF
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Created config template at ${_DF_BLUE}$_DF_CONFIG_FILE${_DF_RESET}"
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Edit this file to customize your dotfiles settings"
    fi
}

# Load configuration from file and environment variables
_df_load_config() {

    # Create config template if it doesn't exist
    _df_create_config_template

    # Load from config file if it exists
    if [[ -f "$_DF_CONFIG_FILE" ]]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue

            # Only process lines containing '='
            [[ "$line" != *"="* ]] && continue

            # Split on first '=' only, preserving '=' in values
            key="${line%%=*}"
            value="${line#*=}"

            # Trim whitespace from key and value
            key="${key#"${key%%[![:space:]]*}"}"    # trim leading
            key="${key%"${key##*[![:space:]]}"}"    # trim trailing
            value="${value#"${value%%[![:space:]]*}"}"  # trim leading
            value="${value%"${value##*[![:space:]]}"}"  # trim trailing

            # Skip if key is empty after trimming
            [[ -z "$key" ]] && continue

            case "$key" in
                default_branch) _DF_DEFAULT_BRANCH="$value" ;;
                cache_duration) _DF_CACHE_DURATION="$value" ;;
                network_timeout) _DF_NETWORK_TIMEOUT="$value" ;;
                auto_update_plugins) _DF_AUTO_UPDATE_PLUGINS="$value" ;;
                github_url) _DF_GITHUB_URL="$value" ;;
            esac
        done < "$_DF_CONFIG_FILE"
    fi

    # Validate and sanitize loaded configuration values
    _df_validate_config
}

# Config validation functions with safe fallbacks
_df_validate_config() {
    # Validate cache_duration (must be positive integer)
    if ! [[ "$_DF_CACHE_DURATION" =~ ^[0-9]+$ ]] || (( _DF_CACHE_DURATION <= 0 )); then
        if [[ "$_DF_CACHE_DURATION" != "43200" ]]; then
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Invalid cache_duration '$_DF_CACHE_DURATION', using default 43200" >&2
        fi
        _DF_CACHE_DURATION=43200
    fi

    # Validate network_timeout (must be positive integer 1-300)
    if ! [[ "$_DF_NETWORK_TIMEOUT" =~ ^[0-9]+$ ]] || (( _DF_NETWORK_TIMEOUT < 1 || _DF_NETWORK_TIMEOUT > 300 )); then
        if [[ "$_DF_NETWORK_TIMEOUT" != "30" ]]; then
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Invalid network_timeout '$_DF_NETWORK_TIMEOUT', using default 30" >&2
        fi
        _DF_NETWORK_TIMEOUT=30
    fi

    # Validate github_url (must be valid HTTPS URL)
    if ! [[ "$_DF_GITHUB_URL" =~ ^https://[a-zA-Z0-9.-]+/[a-zA-Z0-9._/-]+$ ]]; then
        if [[ "$_DF_GITHUB_URL" != "https://github.com/dfinster/dotfiles" ]]; then
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Invalid github_url '$_DF_GITHUB_URL', using default" >&2
        fi
        _DF_GITHUB_URL="https://github.com/dfinster/dotfiles"
    fi

    # Validate default_branch (must be valid git branch name)
    if ! [[ "$_DF_DEFAULT_BRANCH" =~ ^[a-zA-Z0-9._/-]+$ ]] || [[ "$_DF_DEFAULT_BRANCH" =~ ^[.-] ]] || [[ "$_DF_DEFAULT_BRANCH" =~ [.-]$ ]] || [[ "$_DF_DEFAULT_BRANCH" == *".."* ]]; then
        if [[ "$_DF_DEFAULT_BRANCH" != "main" ]]; then
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Invalid default_branch '$_DF_DEFAULT_BRANCH', using default 'main'" >&2
        fi
        _DF_DEFAULT_BRANCH="main"
    fi

    # Validate auto_update_plugins (must be true/false)
    if [[ "$_DF_AUTO_UPDATE_PLUGINS" != "true" && "$_DF_AUTO_UPDATE_PLUGINS" != "false" ]]; then
        if [[ "$_DF_AUTO_UPDATE_PLUGINS" != "true" ]]; then
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Invalid auto_update_plugins '$_DF_AUTO_UPDATE_PLUGINS', using default 'true'" >&2
        fi
        _DF_AUTO_UPDATE_PLUGINS="true"
    fi
}

# Show help function
_df_help() {
    echo -e "Usage: ${_DF_BLUE}dotfiles <command>${_DF_RESET}"
    echo
    echo "Commands:"
    echo -e "  ${_DF_BLUE}update${_DF_RESET}               Apply dotfiles updates from GitHub"
    echo -e "  ${_DF_BLUE}check${_DF_RESET}                Check for available updates"
    echo -e "  ${_DF_BLUE}branch <branchname>${_DF_RESET}  Set the preferred branch"
    echo -e "  ${_DF_BLUE}help${_DF_RESET}                 Show this help message"
    echo
    echo -e "Configuration is stored in ${_DF_BLUE}'$_DF_CONFIG_FILE'${_DF_RESET}."
}

# Git command wrappers to eliminate repetition
_df_git() {
    git -C "$DOTFILES" "$@"
}

_df_git_quiet() {
    _df_git "$@" >/dev/null 2>&1
}


# Get file modification time (cross-platform)
_df_get_file_mtime() {
    local file="$1"
    if is-macos; then
        stat -f %m "$file" 2>/dev/null || echo 0
    else
        stat -c %Y "$file" 2>/dev/null || echo 0
    fi
}

# In-place sed replacement (cross-platform)
_df_sed_inplace() {
    local pattern="$1"
    local file="$2"
    if is-macos; then
        sed -i '' "$pattern" "$file"
    else
        sed -i "$pattern" "$file"
    fi
}


# Temporary cleanup function - remove in next release
_df_cleanup_legacy_cache() {
    local legacy_cache="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles-check-cache"
    if [[ -f "$legacy_cache" ]]; then
        rm -f "$legacy_cache" 2>/dev/null || true
    fi
}

# Common setup function
_df_setup() {
    # Load configuration first
    _df_load_config

    # Clean up legacy cache file (remove in next release)
    _df_cleanup_legacy_cache

    # Exit early if DOTFILES environment variable is not set
    if [[ -z "$DOTFILES" ]]; then
        return 1
    fi

    # Exit early if dotfiles directory doesn't exist
    if [[ ! -d "$DOTFILES" ]]; then
        return 1
    fi

    # Exit early if $DOTFILES is not a git repository
    if ! _df_git_quiet rev-parse --git-dir; then
        return 1
    fi

    # Determine target branch from config (with env var override)
    _DF_TARGET_BRANCH="$_DF_DEFAULT_BRANCH"

    # Get current branch
    _DF_CURRENT_BRANCH=$(_df_git branch --show-current)

    return 0
}

# Switch to target branch if needed
_df_switch_branch() {
    if [[ "$_DF_CURRENT_BRANCH" != "$_DF_TARGET_BRANCH" ]]; then
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Switching to branch ${_DF_BLUE}'$_DF_TARGET_BRANCH'${_DF_RESET}..."

        # Fetch to ensure we have the latest remote refs
        _df_git_quiet fetch origin

        # Try to checkout existing local branch, or create tracking branch if it doesn't exist
        if ! _df_git_quiet checkout "$_DF_TARGET_BRANCH"; then
            # If checkout failed, try to create a new tracking branch
            if ! _df_git_quiet checkout -b "$_DF_TARGET_BRANCH" "origin/$_DF_TARGET_BRANCH"; then
                echo -e "${_DF_RED}Error:${_DF_RESET} Failed to switch to branch ${_DF_BLUE}'$_DF_TARGET_BRANCH'${_DF_RESET}." >&2
                return 1
            fi
        fi
        # Update _DF_CURRENT_BRANCH after successful switch and validate
        local new_current=$(_df_git branch --show-current)
        if [[ "$new_current" == "$_DF_TARGET_BRANCH" ]]; then
            _DF_CURRENT_BRANCH="$_DF_TARGET_BRANCH"
        else
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Branch switch may have failed (expected '$_DF_TARGET_BRANCH', got '$new_current')" >&2
            return 1
        fi
    fi
    echo -e "${_DF_GREEN}Info:${_DF_RESET} On branch ${_DF_BLUE}'$_DF_CURRENT_BRANCH'${_DF_RESET}."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} Restart your terminal to apply changes."
    return 0
}

# Handle branch mismatch between environment and git repository
_df_handle_branch_mismatch() {
    if [[ "$_DF_TARGET_BRANCH" == "$_DF_CURRENT_BRANCH" ]]; then
        return 0  # No mismatch, continue processing (success)
    fi

    echo
    echo -e "${_DF_GREEN}Info:${_DF_RESET} dotfiles configuration mismatch detected."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} dotfiles is on the ${_DF_BLUE}'$_DF_CURRENT_BRANCH'${_DF_RESET} branch."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} dotfiles config is set to the ${_DF_BLUE}'$_DF_TARGET_BRANCH'${_DF_RESET} branch."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} Please use ${_DF_BLUE}'dotfiles branch <branchname>'${_DF_RESET} to choose a branch."
    return 1  # Mismatch detected, stop processing (failure)
}

# Check if cache is recent enough to skip remote check
_df_check_cache_validity() {
    local check_type="$1"

    # Manual checks always bypass cache
    if [[ "$check_type" == "manual" ]]; then
        return 1  # Cache invalid, continue processing
    fi

    # Skip fetch if we've checked recently
    if [[ -f "$_DF_CACHE_FILE" ]]; then
        local cache_time=$(_df_get_file_mtime "$_DF_CACHE_FILE")
        local current_time=$(date +%s)
        if (( current_time - cache_time < _DF_CACHE_DURATION )); then
            return 0  # Cache valid, skip remote check
        fi
    fi

    return 1  # Cache invalid, continue processing
}

# Perform remote update check and display results
_df_perform_remote_check() {
    local check_type="$1"

    # Check if we can reach GitHub (fail silently if offline)
    if ! _df_git_quiet ls-remote origin; then
        return 0
    fi

    # Fetch latest remote information
    _df_git_quiet fetch origin "$_DF_TARGET_BRANCH"

    # Update cache file to record successful check
    touch "$_DF_CACHE_FILE"

    # Check if local branch is behind remote
    local commits_behind
    if ! commits_behind=$(_df_git rev-list --count HEAD..origin/"$_DF_TARGET_BRANCH" 2>/dev/null) || [[ -z "$commits_behind" ]]; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Failed to check for updates (git rev-list failed)" >&2
        return 1
    fi

    # Exit early if up to date (most common case)
    if [[ "$commits_behind" -eq 0 ]]; then
        if [[ "$check_type" == "manual" ]]; then
            echo -e "${_DF_GREEN}Info:${_DF_RESET} Your dotfiles are on the ${_DF_BLUE}$_DF_TARGET_BRANCH${_DF_RESET} branch and up to date."
        fi
        return 0
    fi

    # Show what's new and prompt user to run update
    echo -e "${_DF_GREEN}Info:${_DF_RESET} Newer dotfiles are available."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} You are ${_DF_BLUE}${commits_behind}${_DF_RESET} commit(s) behind the remote."
    echo
    echo -e "${_DF_GREEN}Info:${_DF_RESET} - See changelog at '${_DF_BLUE}$_DF_GITHUB_URL/blob/$_DF_TARGET_BRANCH/CHANGELOG.md${_DF_RESET}' for details."
    echo -e "${_DF_GREEN}Info:${_DF_RESET} - Run '${_DF_BLUE}dotfiles update${_DF_RESET}' to update."
}

# Check for updates function
_df_check() {
    # Setup common variables
    if ! _df_setup; then
        return 0
    fi

    # Handle branch mismatch between environment and repository
    if ! _df_handle_branch_mismatch; then
        return 0
    fi

    # Display info for non-manual checks
    if [[ "$1" != "manual" ]]; then
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Using dotfiles on the ${_DF_BLUE}$_DF_CURRENT_BRANCH${_DF_RESET} branch."
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Run ${_DF_BLUE}dotfiles help${_DF_RESET} for options."
    fi

    # Check cache validity and skip if recent
    if _df_check_cache_validity "$1"; then
        return 0
    fi

    # Perform remote check and display results
    _df_perform_remote_check "$1"
}

# Stash local changes before update
_df_stash_local_changes() {
    # Check if there are any local changes
    if _df_git_quiet diff-index --quiet HEAD --; then
        return 1  # No changes to stash
    fi

    # Attempt to stash changes
    if ! _df_git_quiet stash push -m "Auto-stash before dotfiles update $(date)"; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Failed to stash local changes (git stash failed)" >&2
        return 1
    fi

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Local changes stashed."
    return 0  # Stash created successfully
}

# Perform git pull and update plugins
_df_perform_update() {
    # Pull latest changes from remote
    if ! _df_git_quiet pull origin "$_DF_TARGET_BRANCH"; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Update failed" >&2
        return 1
    fi

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Dotfiles updated successfully."

    # Update antidote plugins if enabled and available
    if [[ "$_DF_AUTO_UPDATE_PLUGINS" == "true" ]] && command -v antidote >/dev/null 2>&1; then
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Updating antidote plugins..."
        if antidote update >/dev/null 2>&1; then
            echo -e "${_DF_GREEN}Info:${_DF_RESET} Antidote plugins updated successfully."
        else
            echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Antidote plugin update failed, but dotfiles update succeeded."
        fi
    fi

    return 0
}

# Restore previously stashed changes
_df_restore_stash() {
    if _df_git_quiet stash pop; then
        echo -e "${_DF_GREEN}Info:${_DF_RESET} Local stash restored successfully."
    else
        echo -e "${_DF_YELLOW}Warning:${_DF_RESET} Local stash could not be restored; you may need to resolve conflicts manually."
        echo -e "${_DF_YELLOW}Warning:${_DF_RESET} You can view the stash with 'git stash list' and apply it manually if needed."
    fi
}

# Update function
_df_update() {
    # Check for updates first (includes setup)
    _df_check manual || return 0

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Updating dotfiles..."

    # Stash any local changes
    local stash_created=false
    if _df_stash_local_changes; then
        stash_created=true
    fi

    # Perform the actual update
    if ! _df_perform_update; then
        return 1
    fi

    # Restore stashed changes if we created a stash
    if [[ "$stash_created" == "true" ]]; then
        _df_restore_stash
    fi

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Please restart your terminal to apply all changes."
}

# Validate branch name to prevent command injection
_df_validate_branch_name() {
    local branch="$1"

    # Check for empty input
    if [[ -z "$branch" ]]; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Branch name is required" >&2
        return 1
    fi

    # Prevent shell metacharacters that could cause command injection
    if [[ "$branch" =~ [\$\`\;\|\&\<\>\(\)] ]]; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Branch name contains invalid characters" >&2
        return 1
    fi

    return 0
}

# Verify branch exists on remote GitHub repository
_df_verify_remote_branch() {
    local branch="$1"

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Checking if branch ${_DF_BLUE}'$branch'${_DF_RESET} exists on GitHub..."

    # Check network connectivity
    if ! _df_git_quiet ls-remote origin; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Cannot connect to GitHub" >&2
        return 1
    fi

    # Check if branch exists
    if ! _df_git_quiet ls-remote --exit-code --heads origin "$branch"; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Branch '$branch' does not exist on GitHub" >&2
        return 1
    fi

    return 0
}

# Update default branch in configuration file
_df_update_config_file() {
    local new_branch="$1"

    echo -e "${_DF_GREEN}Info:${_DF_RESET} Updating default branch to ${_DF_BLUE}'$new_branch'${_DF_RESET} in config file..."

    # Ensure config file exists
    _df_create_config_template

    # Check if file is writable
    if [[ ! -w "$_DF_CONFIG_FILE" ]]; then
        echo -e "${_DF_RED}Error:${_DF_RESET} Cannot write to $_DF_CONFIG_FILE" >&2
        return 1
    fi

    # Atomic config update using temporary file
    local temp_file="${_DF_CONFIG_FILE}.tmp.$$"
    local updated=false

    # Create new config with updated value
    if [[ -f "$_DF_CONFIG_FILE" ]]; then
        # Process existing config line by line
        while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ "$line" =~ ^[[:space:]]*default_branch[[:space:]]*= ]]; then
                echo "default_branch=$new_branch"
                updated=true
            else
                echo "$line"
            fi
        done < "$_DF_CONFIG_FILE" > "$temp_file"
    fi

    # Add default_branch if it wasn't found in existing config
    if [[ "$updated" == "false" ]]; then
        echo "default_branch=$new_branch" >> "$temp_file"
    fi

    # Atomically replace the original file
    if ! mv "$temp_file" "$_DF_CONFIG_FILE"; then
        # Cleanup on failure
        rm -f "$temp_file" 2>/dev/null || true
        echo -e "${_DF_RED}Error:${_DF_RESET} Failed to update config file" >&2
        return 1
    fi

    # Update the variables for this session
    _DF_DEFAULT_BRANCH="$new_branch"
    _DF_TARGET_BRANCH="$new_branch"

    return 0
}

# Set branch function
_df_branch() {
    local new_branch="$1"

    # Validate branch name to prevent command injection
    if ! _df_validate_branch_name "$new_branch"; then
        echo "Usage: dotfiles branch <branchname>"
        return 1
    fi

    # Setup common variables
    if ! _df_setup; then
        return 1
    fi

    # Verify branch exists on remote
    if ! _df_verify_remote_branch "$new_branch"; then
        return 1
    fi

    # Update configuration file
    if ! _df_update_config_file "$new_branch"; then
        return 1
    fi

    # Switch to the branch
    _df_switch_branch
}

# Main function
case "$1" in
    update)
        _df_update
        ;;
    # undocumented alias for silent checks in shell startup
    autocheck)
        _df_check
        ;;
    check)
        _df_check manual
        ;;
    branch)
        _df_branch "$2"
        ;;
    help|--help|-h|"")
        _df_help
        ;;
    *)
        echo -e "${_DF_RED}Error:${_DF_RESET} Unknown command '$1'" >&2
        echo
        _df_help
        return 1
        ;;
esac
